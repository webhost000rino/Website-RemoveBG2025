<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ImagePro - Professional AI Image Processing</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #fafbfc;
      color: #2c3e50;
      line-height: 1.6;
    }

    /* Header */
    header {
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    nav {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 60px;
    }

    .logo {
      font-size: 20px;
      font-weight: 700;
      color: #2563eb;
      text-decoration: none;
    }

    .nav-links {
      display: flex;
      list-style: none;
      gap: 24px;
    }

    .nav-links a {
      text-decoration: none;
      color: #64748b;
      font-weight: 500;
      transition: color 0.3s ease;
    }

    .nav-links a:hover {
      color: #2563eb;
    }

    .cta-button {
      background: #2563eb;
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 14px;
    }

    .cta-button:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
    }

    /* Main Content */
    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 16px;
    }

    .hero {
      text-align: center;
      margin-bottom: 60px;
    }

    .hero h1 {
      font-size: 36px;
      font-weight: 800;
      color: #1e293b;
      margin-bottom: 16px;
      line-height: 1.2;
    }

    .hero p {
      font-size: 16px;
      color: #64748b;
      margin-bottom: 32px;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Upload Section */
    .upload-section {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      padding: 32px 16px;
      margin-bottom: 60px;
      border: 1px solid #e2e8f0;
    }

    .upload-area {
      border: 2px dashed #cbd5e1;
      border-radius: 12px;
      padding: 32px 16px;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      background: #f8fafc;
      position: relative;
    }

    .upload-area:hover {
      border-color: #2563eb;
      background: #f1f5f9;
    }

    .upload-area.dragover {
      border-color: #2563eb;
      background: #eff6ff;
      transform: scale(1.01);
    }

    .upload-icon {
      width: 48px;
      height: 48px;
      margin: 0 auto 16px;
      background: #e2e8f0;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #64748b;
    }

    .upload-text h3 {
      font-size: 20px;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 8px;
    }

    .upload-text p {
      color: #64748b;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .upload-button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 5px;
      min-width: 140px;
      height: 40px;
    }

    .upload-button:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
    }

    .file-types {
      color: #94a3b8;
      font-size: 12px;
    }

    #fileInput {
      display: none;
    }

    .image-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 8px;
      margin: 16px auto;
      display: none;
      object-fit: contain;
    }

    .image-preview.show {
      display: block;
    }

    /* Tools Section */
    .tools-section {
      display: none;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      padding: 24px 16px;
      margin-bottom: 40px;
      border: 1px solid #e2e8f0;
    }

    .tools-section.show {
      display: block;
      animation: fadeInUp 0.5s ease;
    }

    .tools-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }

    .tool-button {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      touch-action: manipulation;
    }

    .tool-button:hover {
      border-color: #2563eb;
      background: #eff6ff;
      transform: translateY(-2px);
    }

    .tool-button.active {
      border-color: #2563eb;
      background: #eff6ff;
    }

    .tool-icon {
      font-size: 24px;
      margin-bottom: 8px;
      color: #2563eb;
    }

    .tool-title {
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 4px;
      font-size: 14px;
    }

    .tool-description {
      font-size: 12px;
      color: #64748b;
    }

    /* Canvas Section */
    .canvas-section {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      padding: 24px 16px;
      text-align: center;
      border: 1px solid #e2e8f0;
      display: none;
    }

    .canvas-section.show {
      display: block;
      animation: fadeInUp 0.5s ease;
    }

    #canvas {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      margin-bottom: 16px;
    }

    .download-section {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }

    .download-button, .upload-button {
      background: #059669;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 140px;
      height: 40px;
      font-size: 14px;
      touch-action: manipulation;
    }

    .download-button:hover, .upload-button:hover {
      background: #047857;
      transform: translateY(-1px);
    }

    .download-button.show {
      display: inline-flex;
    }

    /* Progress Bar */
    .progress-container {
      width: 100%;
      height: 6px;
      background: #e2e8f0;
      border-radius: 3px;
      overflow: hidden;
      margin: 16px 0;
      display: none;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #2563eb, #3b82f6);
      width: 0%;
      transition: width 0.5s ease;
    }

    .processing-text {
      color: #64748b;
      font-size: 12px;
      margin-top: 8px;
      display: none;
    }

    /* Features Section */
    .features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 24px;
      margin-top: 60px;
    }

    .feature-card {
      background: white;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      border: 1px solid #e2e8f0;
      text-align: center;
    }

    .feature-icon {
      width: 64px;
      height: 64px;
      background: #eff6ff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
      font-size: 24px;
      color: #2563eb;
    }

    .feature-title {
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 8px;
    }

    .feature-description {
      color: #64748b;
      line-height: 1.6;
      font-size: 14px;
    }

    /* Animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .nav-links {
        display: none;
      }

      .logo {
        font-size: 18px;
      }

      .cta-button {
        padding: 6px 12px;
        font-size: 12px;
      }

      .hero h1 {
        font-size: 28px;
      }

      .hero p {
        font-size: 14px;
        max-width: 90%;
      }

      .upload-section,
      .tools-section,
      .canvas-section {
        padding: 20px 12px;
      }

      .upload-area {
        padding: 24px 12px;
      }

      .upload-icon {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }

      .upload-text h3 {
        font-size: 18px;
      }

      .upload-text p {
        font-size: 12px;
      }

      .tools-grid {
        grid-template-columns: 1fr;
      }

      .tool-button {
        padding: 12px;
      }

      .tool-icon {
        font-size: 20px;
      }

      .tool-title {
        font-size: 13px;
      }

      .tool-description {
        font-size: 11px;
      }

      .canvas-section h2 {
        font-size: 20px;
      }

      .download-button, .upload-button {
        min-width: 120px;
        height: 36px;
        font-size: 12px;
      }

      .features {
        grid-template-columns: 1fr;
        gap: 16px;
        margin-top: 40px;
      }

      .feature-card {
        padding: 16px;
      }

      .feature-icon {
        width: 48px;
        height: 48px;
        font-size: 20px;
      }

      .feature-title {
        font-size: 16px;
      }

      .feature-description {
        font-size: 12px;
      }

      main {
        padding: 24px 12px;
      }
    }

    @media (max-width: 480px) {
      .hero h1 {
        font-size: 24px;
      }

      .hero p {
        font-size: 12px;
      }

      .upload-button {
        min-width: 100px;
        height: 36px;
        font-size: 12px;
      }

      .image-preview {
        max-height: 150px;
      }
    }
  </style>
</head>
<body>
  <header>
    <nav>
      <a href="#" class="logo"><i class="fas fa-magic"></i> ImagePro</a>
      <ul class="nav-links">
        <li><a href="#features">Features</a></li>
        <li><a href="pricing.html">Pricing</a></li>
        <li><a href="https://webhost000rino.github.io/WebsitesPortofolio/">Contact</a></li>
      </ul>
      <a href="#" class="cta-button">Get Started</a>
    </nav>
  </header>

  <main>
    <section class="hero">
      <h1>Professional AI Image Processing</h1>
      <p>Transform your images with advanced AI algorithms. Remove backgrounds, enhance quality, and compress files with enterprise-grade precision.</p>
    </section>

    <section class="upload-section">
      <div class="upload-area" id="uploadArea">
        <div class="upload-icon">
          <i class="fas fa-cloud-upload-alt"></i>
        </div>
        <div class="upload-text" id="uploadText">
          <h3>Upload Your Image</h3>
          <p>Drag and drop your image here, or click to browse</p>
          <button class="upload-button" id="uploadButton" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-folder-open"></i> Choose File
          </button>
          <p class="file-types">Supports JPG, PNG, WEBP up to 10MB</p>
        </div>
        <img id="imagePreview" class="image-preview" alt="Image Preview">
      </div>
      <input type="file" id="fileInput" accept="image/*">
    </section>

    <section class="tools-section" id="toolsSection">
      <h2 style="text-align: center; margin-bottom: 24px; font-size: 24px; color: #1e293b;">Choose AI Processing Tool</h2>
      <div class="tools-grid">
        <div class="tool-button" onclick="selectTool('background')">
          <div class="tool-icon"><i class="fas fa-cut"></i></div>
          <div class="tool-title">Remove Background</div>
          <div class="tool-description">AI-powered background removal with edge detection</div>
        </div>
        <div class="tool-button" onclick="selectTool('enhance')">
          <div class="tool-icon"><i class="fas fa-magic"></i></div>
          <div class="tool-title">Enhance Quality</div>
          <div class="tool-description">AI upscaling and noise reduction</div>
        </div>
        <div class="tool-button" onclick="selectTool('compress')">
          <div class="tool-icon"><i class="fas fa-compress-alt"></i></div>
          <div class="tool-description">Smart compression with quality preservation</div>
        </div>
        <div class="tool-button" onclick="selectTool('crop')">
          <div class="tool-icon"><i class="fas fa-crop-alt"></i></div>
          <div class="tool-title">Smart Crop</div>
          <div class="tool-description">AI-guided intelligent cropping</div>
        </div>
      </div>
      
      <div class="progress-container" id="progressContainer">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="processing-text" id="processingText">Processing with AI...</div>
    </section>

    <section class="canvas-section" id="canvasSection">
      <h2 style="margin-bottom: 16px; font-size: 20px; color: #1e293b;">AI Processed Result</h2>
      <canvas id="canvas"></canvas>
      <div class="download-section">
        <a href="#" id="downloadLink" class="download-button">
          <i class="fas fa-download"></i> Download Result
        </a>
        <button class="upload-button" onclick="resetEditor()">
          <i class="fas fa-redo"></i> Process Another
        </button>
      </div>
    </section>

    <section class="features" id="features">
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-rocket"></i></div>
        <h3 class="feature-title"> Lightning Fast AI</h3>
        <p class="feature-description">Process images in seconds with our optimized AI algorithms and cloud infrastructure.</p>
      </div>
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-shield-alt"></i></div>
        <h3 class="feature-title">Secure & Private</h3>
        <p class="feature-description">Your images are processed securely and never stored on our servers.</p>
      </div>
      <div class="feature-card">
        <div class="feature-icon"><i class="fas fa-star"></i></div>
        <h3 class="feature-title">Professional Quality</h3>
        <p class="feature-description">Enterprise-grade AI results suitable for professional use and commercial projects.</p>
      </div>
    </section>
  </main>

  <script>
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    const uploadText = document.getElementById('uploadText');
    const uploadButton = document.getElementById('uploadButton');
    const imagePreview = document.getElementById('imagePreview');
    const toolsSection = document.getElementById('toolsSection');
    const canvasSection = document.getElementById('canvasSection');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const downloadLink = document.getElementById('downloadLink');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const processingText = document.getElementById('processingText');

    let currentImage = null;
    let selectedTool = null;

    // File upload handlers
    fileInput.addEventListener('change', handleFileSelect);

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        handleFile(file);
      }
    }

    function handleFile(file) {
      if (!file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }

      if (file.size > 10 * 1024 * 1024) {
        alert('File size must be less than 10MB');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          currentImage = img;
          displayImage(img);
          toolsSection.classList.add('show');
          // Show image preview
          imagePreview.src = e.target.result;
          imagePreview.classList.add('show');
          uploadText.style.display = 'none';
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function displayImage(img) {
      const maxWidth = window.innerWidth > 768 ? 600 : window.innerWidth - 40;
      const maxHeight = 400;
      let { width, height } = img;
      
      if (width > maxWidth || height > maxHeight) {
        const ratio = Math.min(maxWidth / width, maxHeight / height);
        width *= ratio;
        height *= ratio;
      }
      
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
    }

    function selectTool(tool) {
      selectedTool = tool;
      
      // Update active state
      document.querySelectorAll('.tool-button').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.closest('.tool-button').classList.add('active');
      
      // Process image with AI
      processImageWithAI(tool);
    }

    function processImageWithAI(tool) {
      if (!currentImage) return;

      showProgress(tool);

      // Simulate AI processing time based on complexity
      const processingTime = {
        'background': 3000,
        'enhance': 4000,
        'compress': 2000,
        'crop': 1500
      };

      setTimeout(() => {
        switch(tool) {
          case 'background':
            aiRemoveBackground();
            break;
          case 'enhance':
            aiEnhanceImage();
            break;
          case 'compress':
            aiCompressImage();
            break;
          case 'crop':
            aiSmartCrop();
            break;
        }
        
        hideProgress();
        canvasSection.classList.add('show');
        updateDownloadLink();
      }, processingTime[tool]);
    }

    function aiRemoveBackground() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;

      // Step 1: Improved Sobel edge detection
      const edgeMap = new Uint8Array(width * height);
      const sobelThreshold = 60; // Adjusted for better edge detection
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          // Sobel operator with enhanced sensitivity
          let gradientX = 0, gradientY = 0;
          const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
          const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const nIdx = ((y + ky) * width + (x + kx)) * 4;
              const intensity = (data[nIdx] + data[nIdx + 1] + data[nIdx + 2]) / 3;
              const k = (ky + 1) * 3 + (kx + 1);
              gradientX += intensity * sobelX[k];
              gradientY += intensity * sobelY[k];
            }
          }
          
          const edgeStrength = Math.sqrt(gradientX * gradientX + gradientY * gradientY);
          edgeMap[y * width + x] = edgeStrength > sobelThreshold ? 1 : 0;
        }
      }

      // Step 2: Enhanced background detection with multiple criteria
      const backgroundMap = new Uint8Array(width * height);
      const referenceColors = getReferenceBackgroundColors(data, width, height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          const brightness = (r + g + b) / 3;
          const colorVariance = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
          const distance = Math.min(x, y, width - x - 1, height - y - 1);
          
          // Check similarity to reference background colors
          let isSimilarToBackground = false;
          for (const refColor of referenceColors) {
            const colorDiff = Math.sqrt(
              (r - refColor.r) ** 2 +
              (g - refColor.g) ** 2 +
              (b - refColor.b) ** 2
            );
            if (colorDiff < 40) { // Adjustable color similarity threshold
              isSimilarToBackground = true;
              break;
            }
          }
          
          // Enhanced background detection criteria
          const isBackground = (
            (colorVariance < 20 && !edgeMap[y * width + x]) ||
            (brightness > 220 && colorVariance < 30 && !edgeMap[y * width + x]) ||
            (distance < 15 && colorVariance < 25) ||
            (isSimilarToBackground && !edgeMap[y * width + x]) ||
            (brightness > 200 && colorVariance < 35 && distance < 20)
          );
          
          backgroundMap[y * width + x] = isBackground ? 1 : 0;
        }
      }

      // Step 3: Optimized flood fill with color similarity
      function floodFill(startX, startY, referenceColor) {
        const stack = [[startX, startY]];
        const visited = new Uint8Array(width * height);
        while (stack.length) {
          const [x, y] = stack.pop();
          if (x < 0 || x >= width || y < 0 || y >= height) continue;
          const idx = y * width + x;
          if (visited[idx] || backgroundMap[idx] !== 1) continue;
          
          const pixelIdx = idx * 4;
          const r = data[pixelIdx];
          const g = data[pixelIdx + 1];
          const b = data[pixelIdx + 2];
          
          const colorDiff = Math.sqrt(
            (r - referenceColor.r) ** 2 +
            (g - referenceColor.g) ** 2 +
            (b - referenceColor.b) ** 2
          );
          
          if (colorDiff < 50 && !edgeMap[idx]) {
            backgroundMap[idx] = 2;
            visited[idx] = 1;
            stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
          }
        }
      }

      // Start flood fill from corners with their respective colors
      const corners = [
        { x: 0, y: 0 },
        { x: width - 1, y: 0 },
        { x: 0, y: height - 1 },
        { x: width - 1, y: height - 1 }
      ];
      for (const corner of corners) {
        const idx = (corner.y * width + corner.x) * 4;
        const color = { r: data[idx], g: data[idx + 1], b: data[idx + 2] };
        floodFill(corner.x, corner.y, color);
      }

      // Step 4: Apply smooth alpha channel
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const mapIdx = y * width + x;
          
          if (backgroundMap[mapIdx] === 2) {
            let minDistanceToEdge = Infinity;
            for (let dy = -3; dy <= 3; dy++) {
              for (let dx = -3; dx <= 3; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  if (edgeMap[ny * width + nx]) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    minDistanceToEdge = Math.min(minDistanceToEdge, distance);
                  }
                }
              }
            }
            
            const alpha = Math.min(255, Math.max(0, 255 - minDistanceToEdge * 40));
            data[idx + 3] = minDistanceToEdge < 3 ? alpha : 0;
          } else {
            data[idx + 3] = 255;
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function getReferenceBackgroundColors(data, width, height) {
      const corners = [
        { x: 0, y: 0 },
        { x: width - 1, y: 0 },
        { x: 0, y: height - 1 },
        { x: width - 1, y: height - 1 },
        { x: Math.floor(width / 2), y: 0 },
        { x: Math.floor(width / 2), y: height - 1 },
        { x: 0, y: Math.floor(height / 2) },
        { x: width - 1, y: Math.floor(height / 2) }
      ];
      
      const colors = [];
      for (const corner of corners) {
        const idx = (corner.y * width + corner.x) * 4;
        colors.push({
          r: data[idx],
          g: data[idx + 1],
          b: data[idx + 2]
        });
      }
      return colors;
    }

    function aiEnhanceImage() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      // AI-like enhancement with multiple filters
      const enhanced = new Uint8ClampedArray(data);
      
      // Step 1: Noise reduction
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            let count = 0;
            
            // 3x3 gaussian blur for noise reduction
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const weight = dx === 0 && dy === 0 ? 4 : (dx === 0 || dy === 0 ? 2 : 1);
                const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                sum += data[idx] * weight;
                count += weight;
              }
            }
            enhanced[(y * width + x) * 4 + c] = sum / count;
          }
        }
      }
      
      // Step 2: Sharpening and contrast enhancement
      for (let i = 0; i < enhanced.length; i += 4) {
        // Enhanced contrast and sharpness
        enhanced[i] = Math.min(255, Math.max(0, enhanced[i] * 1.15 + 10)); // R
        enhanced[i + 1] = Math.min(255, Math.max(0, enhanced[i + 1] * 1.15 + 10)); // G
        enhanced[i + 2] = Math.min(255, Math.max(0, enhanced[i + 2] * 1.15 + 10)); // B
        
        // AI-like color enhancement
        const brightness = (enhanced[i] + enhanced[i + 1] + enhanced[i + 2]) / 3;
        if (brightness < 128) {
          // Enhance shadows
          const factor = 1.2;
          enhanced[i] = Math.min(255, enhanced[i] * factor);
          enhanced[i + 1] = Math.min(255, enhanced[i + 1] * factor);
          enhanced[i + 2] = Math.min(255, enhanced[i + 2] * factor);
        }
      }
      
      // Step 3: Advanced sharpening filter
      const sharpened = new Uint8ClampedArray(enhanced);
      const sharpenKernel = [
        0, -0.25, 0,
        -0.25, 2, -0.25,
        0, -0.25, 0
      ];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                sum += enhanced[idx] * sharpenKernel[(ky + 1) * 3 + (kx + 1)];
              }
            }
            sharpened[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
          }
        }
      }
      
      const newImageData = new ImageData(sharpened, width, height);
      ctx.putImageData(newImageData, 0, 0);
    }

    function aiCompressImage() {
      // AI-like smart compression that preserves important details
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // Step 1: Analyze image complexity
      let totalVariance = 0;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const variance = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
        totalVariance += variance;
      }
      
      const avgVariance = totalVariance / (data.length / 4);
      
      // Step 2: Adaptive quality based on complexity
      let quality;
      if (avgVariance > 50) {
        quality = 0.85; // High quality for complex images
      } else if (avgVariance > 20) {
        quality = 0.75; // Medium quality
      } else {
        quality = 0.65; // Lower quality for simple images
      }
      
      // Step 3: Smart color quantization
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // Intelligent color reduction while preserving details
        const brightness = (r + g + b) / 3;
        const colorVariance = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
        
        if (colorVariance < 30) {
          // Compress uniform areas more aggressively
          const quantLevel = 16;
          data[i] = Math.round(r / quantLevel) * quantLevel;
          data[i + 1] = Math.round(g / quantLevel) * quantLevel;
          data[i + 2] = Math.round(b / quantLevel) * quantLevel;
        } else {
          // Preserve detail areas with less compression
          const quantLevel = 8;
          data[i] = Math.round(r / quantLevel) * quantLevel;
          data[i + 1] = Math.round(g / quantLevel) * quantLevel;
          data[i + 2] = Math.round(b / quantLevel) * quantLevel;
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      // Final compression using canvas toDataURL
      const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
      img.src = compressedDataUrl;
    }

    function aiSmartCrop() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      // AI-like content-aware cropping
      let minX = width, minY = height, maxX = 0, maxY = 0;
      
      // Find content boundaries using edge detection
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const a = data[idx + 3];
          
          // Check if pixel contains significant content
          const brightness = (r + g + b) / 3;
          const hasContent = a > 50 && (brightness < 240 || brightness > 20);
          
          if (hasContent) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      // Add padding around content
      const padding = Math.min(width, height) * 0.05;
      minX = Math.max(0, minX - padding);
      minY = Math.max(0, minY - padding);
      maxX = Math.min(width - 1, maxX + padding);
      maxY = Math.min(height - 1, maxY + padding);
      
      // Calculate crop dimensions
      const cropWidth = maxX - minX;
      const cropHeight = maxY - minY;
      
      if (cropWidth > 0 && cropHeight > 0) {
        // Extract the cropped region
        const croppedImageData = ctx.getImageData(minX, minY, cropWidth, cropHeight);
        
        // Resize canvas and draw cropped image
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        ctx.putImageData(croppedImageData, 0, 0);
      }
    }

    function showProgress(tool) {
      progressContainer.style.display = 'block';
      processingText.style.display = 'block';
      progressBar.style.width = '0%';
      
      // Update processing text based on tool
      const messages = {
        'background': 'AI analyzing image structure...',
        'enhance': 'AI enhancing image quality...',
        'compress': 'AI optimizing compression...',
        'crop': 'AI detecting content boundaries...'
      };
      
      processingText.textContent = messages[tool];
      
      // Animate progress bar
      let progress = 0;
      const interval = setInterval(() => {
        progress += Math.random() * 15;
        if (progress >= 95) {
          progress = 95;
          clearInterval(interval);
        }
        progressBar.style.width = progress + '%';
      }, 200);
      
      // Complete progress when processing is done
      setTimeout(() => {
        clearInterval(interval);
        progressBar.style.width = '100%';
      }, 2800);
    }

    function hideProgress() {
      setTimeout(() => {
        progressContainer.style.display = 'none';
        processingText.style.display = 'none';
        progressBar.style.width = '0%';
      }, 500);
    }

    function updateDownloadLink() {
      const dataUrl = canvas.toDataURL('image/png');
      downloadLink.href = dataUrl;
      
      // Generate descriptive filename based on selected tool
      const toolNames = {
        'background': 'background-removed',
        'enhance': 'enhanced-quality',
        'compress': 'compressed',
        'crop': 'smart-cropped'
      };
      
      const timestamp = new Date().toISOString().slice(0, 10);
      downloadLink.download = `${toolNames[selectedTool]}-${timestamp}.png`;
      downloadLink.classList.add('show');
    }

    function resetEditor() {
      currentImage = null;
      selectedTool = null;
      toolsSection.classList.remove('show');
      canvasSection.classList.remove('show');
      downloadLink.classList.remove('show');
      fileInput.value = '';
      imagePreview.classList.remove('show');
      uploadText.style.display = 'block';
      
      document.querySelectorAll('.tool-button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Reset canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Advanced image analysis functions
    function calculateImageComplexity(imageData) {
      const data = imageData.data;
      let totalVariance = 0;
      let edgeCount = 0;
      
      for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel for performance
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // Calculate color variance
        const variance = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
        totalVariance += variance;
        
        // Edge detection
        if (variance > 30) edgeCount++;
      }
      
      return {
        variance: totalVariance / (data.length / 16),
        edgeRatio: edgeCount / (data.length / 16)
      };
    }

    function applyGaussianBlur(imageData, radius = 1) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const output = new Uint8ClampedArray(data);
      
      const kernel = generateGaussianKernel(radius);
      const kernelSize = kernel.length;
      const half = Math.floor(kernelSize / 2);
      
      for (let y = half; y < height - half; y++) {
        for (let x = half; x < width - half; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            let weightSum = 0;
            
            for (let ky = -half; ky <= half; ky++) {
              for (let kx = -half; kx <= half; kx++) {
                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                const weight = kernel[ky + half] * kernel[kx + half];
                sum += data[idx] * weight;
                weightSum += weight;
              }
            }
            
            output[(y * width + x) * 4 + c] = sum / weightSum;
          }
        }
      }
      
      return new ImageData(output, width, height);
    }

    function generateGaussianKernel(radius) {
      const size = radius * 2 + 1;
      const kernel = new Array(size);
      const sigma = radius / 3;
      const twoSigmaSquare = 2 * sigma * sigma;
      let sum = 0;
      
      for (let i = 0; i < size; i++) {
        const x = i - radius;
        kernel[i] = Math.exp(-(x * x) / twoSigmaSquare);
        sum += kernel[i];
      }
      
      // Normalize kernel
      for (let i = 0; i < size; i++) {
        kernel[i] /= sum;
      }
      
      return kernel;
    }

    function applySharpenFilter(imageData, strength = 1) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const output = new Uint8ClampedArray(data);
      
      // Adaptive sharpening kernel based on strength
      const center = 4 + strength;
      const edge = -strength / 4;
      const sharpenKernel = [
        0, edge, 0,
        edge, center, edge,
        0, edge, 0
      ];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
            let sum = 0;
            
            for (let ky = -1; ky <= 1; ky++) {
              for (let kx = -1; kx <= 1; kx++) {
                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                sum += data[idx] * sharpenKernel[(ky + 1) * 3 + (kx + 1)];
              }
            }
            
            output[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
          }
        }
      }
      
      return new ImageData(output, width, height);
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'o':
            e.preventDefault();
            document.getElementById('fileInput').click();
            break;
          case 's':
            e.preventDefault();
            if (downloadLink.classList.contains('show')) {
              downloadLink.click();
            }
            break;
          case 'r':
            e.preventDefault();
            resetEditor();
            break;
        }
      }
      
      // Number keys for quick tool selection
      if (currentImage && !e.ctrlKey && !e.metaKey) {
        switch(e.key) {
          case '1':
            selectTool('background');
            break;
          case '2':
            selectTool('enhance');
            break;
          case '3':
            selectTool('compress');
            break;
          case '4':
            selectTool('crop');
            break;
        }
      }
    });

    // Paste from clipboard
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf('image') !== -1) {
          const file = item.getAsFile();
          handleFile(file);
          break;
        }
      }
    });

    // Touch support for mobile
    let touchStartY = 0;
    uploadArea.addEventListener('touchstart', (e) => {
      touchStartY = e.touches[0].clientY;
    });

    uploadArea.addEventListener('touchend', (e) => {
      const touchEndY = e.changedTouches[0].clientY;
      const deltaY = touchStartY - touchEndY;
      
      // Swipe up gesture to open file picker
      if (deltaY > 50) {
        document.getElementById('fileInput').click();
      }
    });

    // Performance monitoring
    function measurePerformance(operation, func) {
      const start = performance.now();
      const result = func();
      const end = performance.now();
      console.log(`${operation} completed in ${(end - start).toFixed(2)}ms`);
      return result;
    }

    // Initialize tooltips for better UX
    function initializeTooltips() {
      const tooltips = {
        'background': 'Uses AI edge detection to remove backgrounds intelligently',
        'enhance': 'Applies noise reduction, sharpening, and contrast enhancement',
        'compress': 'Smart compression that preserves important image details',
        'crop': 'AI-powered content detection for intelligent cropping'
      };
      
      document.querySelectorAll('.tool-button').forEach(button => {
        const tool = button.onclick.toString().match(/'(\w+)'/)[1];
        button.title = tooltips[tool];
      });
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', () => {
      initializeTooltips();
      
      // Add loading animation to upload area
      const icon = uploadArea.querySelector('.fas');
      setInterval(() => {
        if (!currentImage) {
          icon.style.transform = icon.style.transform === 'scale(1.1)' ? 'scale(1)' : 'scale(1.1)';
        }
      }, 2000);
    });
  </script>
</body>
</html>